# (PART) Crashcourse {-}



```{r include = FALSE}
source("common.R")
ds4p_funyoutube <- read.csv("admin/csv/ds4p_funyoutube.csv", sep="")
ds4p_urls <- read.csv("./admin/csv/ds4p_urls.csv")
```

# Welcome to a markdown crashcourse

Note: Adapted from [Zachary M. Smith](https://github.com/zsmith27/rmarkdown_crash-course)
]
# Lesson 1: R Project Development

## Overview

* Easier to access files (relative path)
    + Relative paths help prevent broken paths
        + In general, DO NOT use setwd()
        + Will work if the project folder is moved to a new location on you local machine or moved to a new machine.
* Designed to easily integrate with version control (GIT)
* In general, all data, scripts, and output should be stored within the project directory.

## Create a New R Project

1. Create a new R project by clicking on the drop-down menu at the top right of RStudio and selecting "New Project"

![](img/r_project/create_project.png){width=1000px}

2. Select "New Directory" within the "Create Project" window

![](img/r_project/new_directory.png){width=500px}

3. Select "New Project" within the "Project Type" window

![](img/r_project/project_type.png){width=600px}

4. Enter a project name (below I have given the name "new_project"), the project directory (where the project should live), and select "Create Project"
    + __Tip: Create a "project" folder that will act as your parent directory for all R projects. This will make it much easier to navigate to and between projects.__

![](img/r_project/create_new_project.png)

5. A new session specific to your R project will start within RStudio
    + There are a number of ways to tell which project is open...

![](img/r_project/fresh_project.png)

## Navigate Between Projects

Quickly navigate between recently opened R projects by clicking on the drop-down menu at the top right of RStudio and selecting the project of interest.

![](img/r_project/nav_project.png){width=400px}


## Recommended Workflow

1. Set up a GitHub repository.
2. Create an R-project connected to the GitHub repository.
3. Develop R-scripts.
4. Push and pull project changes to and from GitHub.

![](img/r_project/workflow.png)

## Your Turn

1. Open R Studio.
2. Create a new Project.
3. Add an "data" folder and add the example data set to this folder.
4. Create a new R Script (Ctrl + Shift + N) and save the script as "lesson_1.R" to your project root folder.
5. Add the following script and run it (Ctrl + Enter)
    + Notice that the entire file path to CSV of interest ("zms_thesis_metrics.csv") was not specified just `file.path("data", "zms_thesis_metrics.csv")`.
```{r, eval=FALSE}
thesis.df <- read.csv(file.path("data",
                                "zms_thesis_metrics.csv"),
                      stringsAsFactors = FALSE)

head(thesis.df)
```
6. View `thesis.df` in the Environment panel
    + How many rows and columns does our data frame have?
    + Click on the drop-down menu (the blue circle to the left of `thesis.df`). 
        + Can you identify the column type (e.g., Character, Numeric, Integer, or Factor) of the columns `unique_id`, `substrate_size_d50`, `richness`, and `pct_diptera`?
        + What are the first, second, and third `unique_id`'s represented in the data frame and which `richness` values are associated with each `unique_id`?
    + Click on the button to view the data (the small girdded table to the far-right of `thesis.df`)
        + Filter the data frame to only see data from Onondaga Lake (`lake` = "onon")
        
        

# Lesson 2: Rmd Creation

##	Create a New Document

1. Click on the new document button: 

![](img/rstudio/new_document_button.png)

2. Click on R Markdown:

![](img/rmarkdown/rmarkdown_button.png){width=400px}

3. Provide a "Title:", select the "Default Output Format:", and click "OK"

![](img/rmarkdown/new_rmarkdown_window.png){width=600px}

4. A new R Markdown document will appear with some instructions and example text/code.

![](img/rmarkdown/new_rmarkdown_window.png){width=600px}

##	Compile the Document

![](img/rmarkdown/knit_button.png){width=160px}

To view the html document, you must compile the document using Knit. The easiest way to knit a document is to navigate to and click on the Knit button (it looks like a ball of yarn) in the toolbar above the editor window. If a window appears saying "Install Required Packages" for R Markdown, install the necessary packages for knitting the document. The compiled file will be saved in the same directory as your Rmd file (your R Markdown file). I generally store the R Markdown file(s) in a sub-directory labeled "rmarkdown" within the R-project folder (rproject/markdown), which prevents the project directory from becoming cluttered-- this is __NOT__ necessary.

You can click on the small triangle to the right of the Knit button to view a drop-down menu of knitting options. Here you have the option to update the document type you want to knit (examples listed below).

* Knit to HTML
* Knit to PDF
* Knit to Word

By clicking one of these options your YAML header updates automatically. We will discuss YAML headers in a later section, but in short the YAML header defines some of the formatting options associated with the document, including the output type. You can have multiple document types render at once (e.g., a separate HTML and Word document are created with each knit call).  

## Document Types

There are multiple document types available which designate how the .Rmd file will be rendered (knit).

### HTML

Knitting to a Hyper Text Markup Language (HTML) document is the default for R Markdown. Using HTML will enable you to add interactive features to your document. To view HTML documents, simply open them in your internet browser of choice-- by default, your machine should open HTML documents in your default browser automatically.

#### R Markdown vs. R Notebook

R Markdown documents (`html_documents`) and R Notebook documents (`html_notebook`) are very similar; in fact, an R Notebook document is a special type of R Markdown document. The main difference is using R Markdown document (`html_documents`) you have to knit (render) the entire document each time you want to preview the document, even if you have made a minor change. However, using an R Notebook document (`html_notebook`) you can view a preview of the final document without rendering the entire document. 

For all document types you can specify how you want to preview the rendered documents by clicking on the cog in the Source window toolbar to reveal a drop-down menu of options. The recommended setup for use of an R Notebook document would be to specify you want to view the preview in the Viewer pane (i.e., the bottom right pane shared with Files, Plots, Packages, and Help).

![](img/rmarkdown/rmarkdown_cog_preview-chunk-output-inline.png){}

Then click on the "Preview" button in the Source window toolbar to render a preview of the final document.

![](img/rmarkdown/rnotebook_preview-button.png){}

Keep the Viewer pane open and do not close the preview of the document. Now begin to edit the markdown syntax in the document. Each time you save the document the preview window will render the changes made to the markdown syntax. If you edit R code chunks, you must run the code chunks within the notebook file prior to saving to see the changes in the Viewer window.


### PDF

You have the ability to knit to Portable Document Format (PDF) but you will not be able include interactive features in the document. Knitting to a PDF requires you to have the program LaTeX installed. You will get the following error message if you try to knit a PDF document without LaTeX installed on your machine:
> No LaTeX installation detected (LaTeX is required to create PDF output). You should install a LaTeX distribution for your platform: https://www.latex-project.org/get/
If you are not sure, you may install TinyTeX in R: tinytex::install_tinytex()
Otherwise consider MiKTeX on Windows - http://miktex.org
MacTeX on macOS - https://tug.org/mactex/
(NOTE: Download with Safari rather than Chrome _strongly_ recommended)
Linux: Use system package manager

### Word

You have the ability to knit to Microsoft Word if you have Microsoft Word installed on your machine. Similarly to PDFs, you will not be able to include interactive features in your Word documents.

### Templates

#### Provide Templates

There are a number of templates you can install or will come with packages you install, which you can view in the pop-up window that appears when you select that you want to create a new R Markdown file.

![](img/rmarkdown/from_template.png){}

These templates may give you a jump-start to provide a large portion of the formatting specification to make specific documents. Some example templates from the package __pagedown__ are:

* Business Card
* Letter
* Paged HTML Documents
* Resume
* Journal Article
* Poster
* Thesis
* Package Vignette

#### Custom Templates

You also have the ability to specify custom templates in your YAML header. We will discuss YAML headers in a later section ([Lesson 4: YAML Headers]). 

I have only used this feature for Microsoft Word documents. I created a new document within Microsoft Word and selected all of the formatting options I wanted for my document. I then added the template to the YAML header of my R Markdown document to specify that when the document is knit (rendered) to apply the formatting specifications found in the template Microsoft Word document.

### Other Types

#### Presentations

You have the ability to create presentation slides using R Markdown. Below are the different format options available. Examples can be found in the following link under the "Presentation" section: https://rmarkdown.rstudio.com/gallery.html

* ioslides (HTML)
* Slidy (HTML)
* Beamer (PDF)
    + Requires LaTeX
* Microsoft PowerPoint
    + Requires Microsoft PowerPoint
    
I have tried to create presentations with R Markdown on several occasions but I always revert back to using Microsoft PowerPoint. I have not found these slides to be very flexible and seem to only be able to generate simple slides without much content. My recommendation would be to try these slides out if you are making a presentation demonstrating how to use simple R code.

#### Shiny Documents

Shiny documents enable you to embed a shiny application into an R Markdown document. This will enable you to insert custom interactive features into your document. The final document will need to be an HTML file.

## Your Turn

1. Create a new HTML .Rmd file.
2. Save the document to your project root folder.
3. Knit the default document produced by RStudio.
4. Using the Knit drop-down menu, specify that you want to create a Word document.
   + This will only be possible if you have Microsoft Word installed on your machine.
5. __Bonus:__ Try creating new R Markdown documents and selecting Presentation, Shiny, and other templates available. Each selection will provide you with an example .Rmd file that you can knit (render) and explore.

# Lesson 3: Basic Syntax

* __Source:__ https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf

<center>
![](img/rmarkdown/reference.png){width=800}
</center>

##	Heading Text

Heading text follows one or more hash-sign(s) (#). The number of hash-signs determines the hierarchy of headings. For example, "# Heading 1" would represent the primary heading, "## Heading 2" would represent the secondary heading, "### Heading 3" would represent the tertiary heading, and so forth.

##	Plain Text

Simply add text below the YAML header. To start a new paragraph, you will need to end your plain text line with two (2) spaces.

## __Bold__ and _Italicized_ Text

There are two ways to format your text to be __bold__ or _italicized_.

* __Bold__
    + Surround your text with two (2) asterisks (*) on each side.
    + Surround your text with two (2) underscores (_) on each side.
* _Italicized_
    + Surround your text with one (1) asterisk (*) on each side.
    + Surround your text with one (1) underscore (_) on each side.
  
The markdown syntax...

![](img/rmarkdown/bold_italics_syntax.png){}

which renders to...

**Bold Text Example**

__Bold Text Example__

*Italicize Text Example*

_Italicize Text Example_
  
## Lists

### Unordered Lists

Unordered or bulleted lists can be generated by using a single asterisk (*) followed by a space and the plain text intended to represent the bullet. To add another bullet, just hit enter or return and follow the previous steps. To add sub-bullets, insert two spaces and a plus sign (+) followed by a space and the plain text intended to represent the sub-bullet. You can do this at multiple levels; meaning you can add four spaces and a plus sign (+) to insert a sub-sub-bullet and six spaces and a plus sign (+) to add a sub-sub-sub-bullet.

The markdown syntax...

![](img/rmarkdown/unordered_list_syntax.png){}

which renders to...

* Bullet 1
* Bullet 2
    + Sub-Bullet 1
    + Sub-Bullet 2
        + Sub-Sub-Bullet 1
        + Sub-Sub-Bullet 2

### Ordered Lists

Follow the steps in Unordered Lists but instead of using asterisk (*) use sequential numbers followed by a period (.)-- this cannot be done for sub-bullets. For example, "1.", "2.", and "3.". 

The markdown syntax...

![](img/rmarkdown/ordered_list_syntax.png){}

which renders to...

1. Bullet 1
    + Sub-Bullet 1
2. Bullet 2
    + Sub-Bullet 1
    + Sub-Bullet 2
        + Sub-Sub-Bullet 1

## Link to a Section

You can link to a section within the document by surrounding the name of the section in square brackets. 

The markdown syntax...

`[Lesson 3: Basic Syntax]`

would render to this...

[Lesson 3: Basic Syntax]

If you click on the "Lesson 3: Basic Syntax" above, it will jump you to the head of this section.

## Hyperlink

You simply need to paste in a full URL into your document and it will automatically be recognized as a hyperlink. For example...

https://bookdown.org/yihui/rmarkdown

If you want to hide the full link and represent it with text, then surround the text with square brackets followed by the URL in parenthesis. 

The markdown syntax...

`[link](https://bookdown.org/yihui/rmarkdown/)`

would render to this...

[link](https://bookdown.org/yihui/rmarkdown/).

## Insert Images

You can insert images into your document using syntax similar to the hyperlink syntax above. 

In the code below, you can see the file path the to the image. This image will render without a caption

`![](img/hex_symbols/rmarkdown.png)`

![](img/hex_symbols/rmarkdown.png)

You can add a caption for the image in between the square brackets.

`![This is my caption for the image.](img/hex_symbols/rmarkdown.png)`

![This is my caption for the image.](img/hex_symbols/rmarkdown.png)

You can control the size of the image like this...

`![This is my caption for the image.](img/hex_symbols/rmarkdown.png){width=200px}`

![This is my caption for the image.](img/hex_symbols/rmarkdown.png){width=100px}

You can center the image with HTML like this...

![](img/rmarkdown/centered_image.png)

<center>
![This is my caption for the image.](img/hex_symbols/rmarkdown.png){width=100px}
</center>

## Tabbed Sections

Tabbed sections can be added to section of an HTML documents that will fold all of the subsequent sub-sections into separate tabs. To do this you specify a section header followed by `{.tabset}`. For example, `## My Section Header {.tabset}`.

![](img/rmarkdown/tabset.png){}

Note this feature is not available for use with __bookdown__.

## Your Turn

1. Using the .Rmd file created in [Lesson 2: Rmd Creation], delete everything below the YAML header.
2. Add the following level-1 headers and knit the document.
    + Introduction
    + Workflow
    + Import Data
    + Preprocessing
    + Study Area
    + Plot
    + Conclusions
3. Add two level-2 headers below the Plot header and knit the document.
    + Scatter Plot
    + LOESS Plot
3. Add plain text below the Introduction header and knit the document.
    + Be sure to include some __bold__ and _italicized_ text.
    + Explain the purpose of the document (e.g., "This document was created during the 2020 NABs R Markdown workshop and will serve as an example workflow for my future use of R Markdown.")
    + Include the hyperlink to R Markdown: The Definitive Guide (https://bookdown.org/yihui/rmarkdown/). This will be a helpful resource in the future.
4. Add unordered or ordered list below the Workflow header and knit the document.
    + Describe the workflow we have talked about thus far (e.g., create an R project, add folders, create an rmarkdown document, knit the document to render).
    + Add sub-bullets with helpful details.
5. Add the image provided with the data to the Introduction.
6. Make the Plot section tabbed section with `{.tabset}`.


# Lesson 4: YAML Headers

__YAML:__ YAML Ain't Markup Language

A YAML header contains YAML arguments, such as "title", "author", and "output", demarcated by three dashes (---) on either end.

<center>
![](img/rmarkdown/yaml_1.png)
</center>

## Title

The specified title (`title: "My Title"`) will appear at the head of the document with a larger font size than the rest of the document.

### Subtitle

You can specify subtitle (`subtitle: "My Subtitle"`), which will appear below and in slightly smaller font size than the title of the document.

## Author(s)

An author can be specified (`author: "Zachary M. Smith"`) and will appear at the head of the document but below the title(s). You can specify multiple authors by separating the names of the authors by a comma (`author: "Zachary M. Smith, John Doe"`).

## Date

You can supply a date (`date: "March 3rd, 2020"`) that will be added to the head of the document. You can specify a static date (`date: "March 3rd, 2020"`) or a dynamic date (see image below) that will update each time you knit (render) the document-- we will discuss this further in a subsequent section.

<center>
![](img/rmarkdown/yaml_dynamic-date.png)
</center>

## Table of Contents (TOC)

<center>
![](img/rmarkdown/yaml_2.png)
</center>

### Floating Table of Contents (TOC)

<center>
![](img/rmarkdown/yaml_3.png)
</center>

## Themes

You can modify the YAML to specify the .theme of the document, which will change document styling (e.g., font type, color, size)

The following link provides examples of some of the available R Markdown themes: https://www.datadreaming.org/post/r-markdown-theme-gallery/


<center>
![](img/rmarkdown/yaml_4.png)
</center>

## Code Folding

Code folding refers to the HTML YAML option to hide code chunks by default, but enable the reader to click a button to show the underlying code chunk.

### Example without Code Folding

<center>
![](img/rmarkdown/folding_non.png)
</center>

### Examples with Code Folding

#### Show

<center>
![](img/rmarkdown/folding_show.png)
</center>

#### Hide

<center>
![](img/rmarkdown/folding_hide.png)
</center>

## output

The output option allows you to specify the type of document you want to create. This will be auto-populated if you generate the .Rmd file in RStudio by creating a new R Markdown file through the toolbar. You can manually modify the output type, but you must specify valid arguments.

Some valid arguments include:

* `html_document`
* `html_notebook`
* `pdf_document`
* `word_document`

You can click on the small triangle to the right of the Knit button to view a drop-down menu of knitting options. Here you have the option to update the document type you want to knit (examples listed below).

* Knit to HTML
* Knit to PDF
* Knit to Word

By clicking one of these options, your YAML header updates automatically. You can have multiple document types render at once (e.g., a separate HTML and Word document are created with each knit call).  

<center>
![](img/rmarkdown/yaml-two-outputs.png)
</center>

## Custom Template

You have the ability to specify custom templates in your YAML header. 

I have only used this feature for Microsoft Word documents. I created a new document within Microsoft Word and selected all of the formatting options I wanted for my document. I then added the template to the YAML header of my R Markdown document to specify that when the document is knit (rendered) to apply the formatting specifications found in the template Microsoft Word document.

<center>
![](img/rmarkdown/yaml_word-template.png)
</center>

## ymlthis

__ymlthis__ is an R package intended to make it easier for you to generate YAML headers. The package also includes an interactive addin that provides an intuitive user-interface for generating YAML headers. You can visit the following link to learn more about how to use ymlthis: []https://ymlthis.r-lib.org/

Addins can be accessed by navigating to "Tools" in the RStudio banner, scrolling down to "Addins", and selecting "Browse Addins." A pop-up window will appear. If you have __ymlthis__ installed on your machine, you will see the __ymlthis__ addin in the pop-up window table. Once you select the __ymlthis__ addin, you will see a pop-up window like this...

<center>
![](img/rmarkdown/ymlthis_popup.png)
</center>

## Your Turn

1. Edit the YAML title and author and knit the document.
2. Specify in the YAML that you want to include a table of contents and knit the document.
3. Specify in the YAML that you want a floating table of contents and knit the document.
4. Specify in the YAML that you want to change the theme to "journal" and knit the document.
5. If you have Microsoft Word installed on your computer, change the YAML output to `word_document` and the knit the document.

6. __Bonus:__ If you finish early, install __ymlthis__ (`install.packages("ymlthis")`), navigate to the __ymlthis__ addin, and try to re-create the YAML header from steps 1-4.



# Lesson 5: Code Chunks and Inline Code

Up to this point in the workshop we have mostly just written a standard markdown document. However, we want to integrate R code into our document to create reproducible objects, such as figures, tables, and text. 

## Code Chunks

To insert a code chunk, press __Ctrl + Alt + I__ in the source pane (top left pane in the default settings of RStudio). A code chunk will appear: ![](img/rmarkdown/code_chunk.png)

Inside the code chunk you can write and run R-code. If you print the output of your R-code it will appear below the code chunk in the source pane and the printed output will appear in the final compiled document. This is useful for producing figures and tables.

![](img/rmarkdown/example_chunk_ouptut.png)

* On the far right of the code chunk you will see three buttons. 
    + The cog makes it easy to specify code chunk options-- discussed below.
    + The middle button will execute all code chunks prior to a given function (`Ctrl + Alt + P`)
    + The far right button will execute all of the code in a code chunk.
    
<center>
![](img/rmarkdown/code-chunk_tools.png)
</center>

### Shortcuts

__You will want to learn these ASAP.__

* `Ctrl + Alt + I` - Insert a new code chunk
* `Ctrl + Enter` - Run the line of code your cursor is on
* `Ctrl + Alt + R` - Run all of the code in the document
* `Ctrl + Alt + P` - Run all code chunks above your cursor
* `Ctrl + Shift + F10` - Restart R

### Options

There are a number of code chunk options that can be specified in the code chunk header to modify how the code chunk is rendered while kniting. These options will not be visible in the rendered document-- even if you choose not to hide the code chunks in your rendered document.

A comprehensive list of chunk options can be found here: https://yihui.org/knitr/options/

#### name

Best practice is to include a short and unique name within each code chunk header. This will be especially beneficial if you need to troubleshoot an error in your document as you will be able to track the source of the error down by code chunk name. The "name" is not specified as an argument within the header; it is simply separated from the "r" by a space. This is exemplified in the image below on line 9 where "addition" is supplied as the name of the code chunk (`{r addition}`).

![](img/rmarkdown/code-chunk_name.png)

#### echo

A logical value (true or false) indicating if the code chunk should be visible in the rendered document. By default the code chunk will be visible upon knitting (`echo=true`). To hide a specific code chunk set echo to "false" (`echo=false`).

Include the code chunk in the rendered document with `echo=true`.
![](img/rmarkdown/code-chunk_echo-true.png)

Exclude the code chunk in the rendered document with `echo=false`.
![](img/rmarkdown/code-chunk_echo-false.png)

#### fig.width, fig.height, and fig.cap

The `fig.width` and `fig.height` options allow you to control the size of the figure generated from a given code chunk. `fig.cap` provides the ability to add a caption below the figure generated from a given code chunk.

Here is an example of the plot output form a code chunk.
![](img/rmarkdown/fig-options_default.png)

Here I have specified `fig.width`, `fig.height`, and `fig.cap`. Notice that plot dimensions have changed from the previous image and a caption has been added to the bottom of the figure.
![](img/rmarkdown/fig-options_fig-cap-default.png)

In many cases, you will want the captions to be numbered and you will want this to occur automatically. To this you will first need to install the package __bookdown__ (`install.packages("bookdown")`). Specify in the YAML header that the output should be "html_document2" from the __bookdown__ package (`output: bookdown::html_document2`). When you render the document the figures will now be automatically numbered by the order they appear in the document. To cross reference a figure by name in the text use `\@ref(fig:figure_name)`. Using the example from the figure below, you might write "In `\@ref(fig:IrisScatter)` we can see that the species setosoa tend to have shorter sepal lengths than the other two species." For more information visit https://bookdown.org/yihui/rmarkdown-cookbook/figure-number.html.
![](img/rmarkdown/fig-options_fig-cap-bookdown-html2.png)

#### message and warning

Using `message=FALSE` and/or `warning=FALSE` will suppress messages and warnings preventing them from printing in the rendered document. __Warning:__ Suppress these messages/warnings at your own risk. Without these messages/warnings you may make it very difficult to track down any issues in your code. 

An example of messages that are produced with the default `message=TRUE`.
![](img/rmarkdown/code-chunk_message-true.png)

The messages above can be suppressed by setting `message=FALSE` in the code chunk header.
![](img/rmarkdown/code-chunk_message-false.png)

#### include

Code chunk headers with `include=FALSE` will be ignored when the document is rendered. This can be useful during document development. For example, you may have a code chunk producing an error that prevents you from rendering the rest of your document or you may be questioning the need to keep a given code chunk. `include=FALSE` will exclude the code from the rendered document without deleting the code entirely from the .Rmd file.

The default is `include=TRUE`. In the example below, `include` is not altered from the default and therefore all of the code chunks are present in the rendered document.
![](img/rmarkdown/code-chunk_include-true.png)

In the example below I added `include=FALSE` to the header of the second code chunk named "iris-sepal-scatter." The second code chunk is excluded from the rendered document.
![](img/rmarkdown/code-chunk_include-false.png)

#### Setting Global Options

It can be helpful to establish global options to produce a standard format throughout the document. You can set this with the __knitr__ function `opts_chunk$set()`. For instance, you may want to set a standard dimensions for figures produced by code chunks throughout your document. In the code chunk below, you can see that I set `fig.width` to 8 and `fig.height` to 4. 

```{r global-options, eval=FALSE}
knitr::opts_chunk$set(fig.width = 8, fig.height = 4)
```

The options specified in `opts_chunk$set()` become the default when rendering the document. However, you still have the ability to overwrite these options for specific code chunks. Building off of the previous example, you may find that one out of ten of your plots is not aesthetically pleasing with `fig.width = 8` and `fig.height = 4`. You could specify in the code chunk producing that plot that you want to set `fig.width = 6` and `fig.height = 6`, for example.

## Inline Code

Inline code enables you to insert R code into your document to dynamically updated portions of your text.

To insert inline code you need to encompass your R code within:
![](img/rmarkdown/inline_syntax.png).

For example, you could write:

![](img/rmarkdown/inline_example_iris-mean-sepal-length.png)
__Which would render to:__ The mean sepal length found in the _iris_ data set is `r mean(iris$Sepal.Length)`.

I frequently use inline code to make my YAML header date update to the date the document was last rendered.

<center>
![](img/rmarkdown/inline_yaml-date.png)
</center>

You can reformat the date using the `format()` function, as depicted in the image below.
![](img/rmarkdown/inline_yaml-date-format.png)

## Your Turn (Part 1)

_The point of this exercise is to get you familiar with code chunks and inline code, NOT to test your R knowledge; therefore, I have included the necessary code below each task._

1. Add a code chunk using __Ctrl + Alt + i__ to import the example data set.
    + `read.csv(file = file.path("data", "zms_thesis_metrics.csv"), stringsAsFactors = FALSE)`
    + Add a name to this code chunk header and all subsequent code chunk headers.
    + Add plain text description above the code chunk.
    + Add the following unordered list describing the contents of the imported data.
        + `unique_id` (character) unique sample ID
        + `lake` (character) lake code: caz = Cazenovia lake, onon = Onondaga, and ot = Otisco
        + `lat` (numeric) latitude of sampling location
        + `long` (numeric) longitude of sampling location
        + `substrate_size_d50` (numeric) median particle size from pebble count
        + `conductivity` (numeric) specific conductivity (µS/cm)
        + `richness` (numeric) taxonomic richness
        + `shannon` (numeric) Shannon-Wiener diversity index values
        + `pct_ephemeroptera` (numeric) relative abundance of Ephemeroptera taxa
        + `pct_amphipoda` (numeric) relative abundance of Amphipoda taxa
        + `pct_diptera` (numeric) relative abundance of Diptera taxa
        + `dom_1` (numeric) relative abundance of the most dominant taxon observed in each sample
2. Add a code chunk to import the __tidyverse__ packages.
    + `library(tidyverse)`
    + Add plain text description above the code chunk.
    + Add `message=FALSE` to the code chunk header to prevent the package start-up messages
3. Add a code chunk below `libary(tidyverse)` to preprocess lake name (`lake`) associated with each sample.
```{r prep-lake-example, eval=FALSE}
thesis.df <- thesis.df %>% 
  mutate(lake = case_when(
    lake %in% "caz" ~ "Cazenovia",
    lake %in% "onon" ~ "Onondaga",
    lake %in% "ot" ~ "Otisco",
    TRUE ~ "ERROR"
  ),
  lake = factor(lake, levels = c("Onondaga",
                                 "Otisco",
                                 "Cazenovia")))
```
4. Add a code chunk just below the YAML header to specify global code chunk options
    + specify `fig.width` and `fig.height`
    + in the header specify `echo=FALSE` to hide this code chunk-- your reader does not need to see this
```{r global-options-example, eval=FALSE}
knitr::opts_chunk$set()
```

7. Add a code chunk to generate a scatter plot.
    + Add a caption
```{r scatter-example, eval=FALSE}
ggplot(thesis.df, aes(substrate_size_d50, pct_diptera, color = lake)) +
  geom_point()
```
8. Add a code chunk generate a boxplot.
    + Modify the figure size
    + Add a caption
```{r boxplot-example, eval=FALSE}
ggplot(thesis.df, aes(lake, richness, fill = lake)) +
  geom_boxplot()
```
9. Add a brief interpretation of the figures into the "Conclusions" section.
10. __Bonus:__ Try using the cog at the top right of the code chunk to update a code chunks options.

<center>
![](img/rmarkdown/code-chunk_tools.png)
</center>
        
## Interactive Features

Interactive tables and figures are a great way to make your document more interesting and can be very useful for data exploration. I will warn you that if you use these features too frequently your document will become cluttered and will likely load and run slowly.

### DT

The __DT__ package enables you and your readers to interact with tables in your document. You can filter and sort the table to view data that you are most interested in exploring or understanding.

For more information visit https://rstudio.github.io/DT/

```{r}
library(DT)

datatable(iris)
```

### Plotly

__Plotly__ makes it easy to create interactive figures. Some of the most useful features  are the ability to...

* rollover figure objects and see a pop-up information related to specific features
* Zoom-in and zoom-out
* take a picture of the figure

For more information visit: https://plot.ly/ggplot2/

I generally use __plotly__ in conjunction with __ggplot2__. The __plotly__ function, `ggplotly()`, makes it simple to convert __ggplot2__ figures to interactive __plotly__ figures.
```{r plotly_example, message=FALSE}
library(plotly)

scatter.plot <- ggplot(iris, aes(x = Petal.Width, y = Petal.Length,
                                 color = Species)) +
  geom_point()

ggplotly(scatter.plot)
```

### Leaflet

__Leaflet__ is a great resource for creating interactive maps with minimal amount of coding.

For more information visit: https://rstudio.github.io/leaflet/

```{r}
library(leaflet)

data("quakes")

leaflet(
  data = quakes,
  options = leafletOptions(
    minZoom = 4,
    maxZoom = 18
  )
) %>%
  addTiles() %>%
  addCircleMarkers(~long, ~lat,
    fillOpacity = 0.75,
    stroke = FALSE,
    popup = paste(
      "Sample ID:", quakes$unique_id, "<br/>",
      "Magnitude:", quakes$mag, "<br/>",
      "Latitude:", quakes$lat, "<br/>",
      "Longitude:", quakes$long
    )
  )
```

Another neat feature is the ability to cluster points to better visualize density. You can do this by setting `clusterOptions = markerClusterOptions()`.
```{r}
library(leaflet)

data("quakes")

leaflet(data = quakes,
        options = leafletOptions(minZoom = 4,
                                 maxZoom = 18)) %>% 
  addTiles() %>% 
  addCircleMarkers(~long, ~lat,
                   fillOpacity = 0.75,
                   stroke = FALSE,
             popup = paste("Sample ID:", quakes$unique_id, "<br/>",
                           "Magnitude:", quakes$mag, "<br/>",
                           "Latitude:", quakes$lat, "<br/>",
                           "Longitude:", quakes$long),
             clusterOptions = markerClusterOptions()
             )
```

## Your Turn (Part 2)

1. Add a code chunk below the "Preproccessing" header and add the following __DT__ code
    + add this link (https://rstudio.github.io/DT/) to your description above the code chunk to describe where you can find more information on __DT__
```{r dt-example, eval=FALSE}
library(DT)

datatable(thesis.df, options = list(scrollX = TRUE))
```

2. Add a code chunk below the "Study Area" header and add the following __leaflet__ code
    + add this link (https://rstudio.github.io/leaflet/) to your description above the code chunk to describe where you can find more information on __leaflet__
```{r leaflet-example, eval=FALSE}
library(leaflet)

pal <- colorFactor(c("#619Cff", "#F8766D", "#00BA38"),
                   domain = c("Cazenovia", "Onondaga", "Otisco"))

leaflet(data = thesis.df,
        options = leafletOptions(minZoom = 7,
                                 maxZoom = 13)) %>% 
  addTiles() %>% 
  addCircleMarkers(~long, ~lat,
                   fillOpacity = 0.75,
                   fillColor = ~pal(lake),
                   stroke = FALSE,
             popup = paste("Sample ID:", thesis.df$unique_id, "<br/>",
                           "Lake:", thesis.df$lake, "<br/>",
                           "Latitude:", thesis.df$lat, "<br/>",
                           "Longitude:", thesis.df$long)
             )
```

3. Edit the scatter plot code chunk to make the figure interactive with __plotly__
    + add this link (https://plot.ly/ggplot2/) to your description above the code chunk
    + play around with the interactive plot and the tools provided at the top right of the plot
        + For example, you can zoom in, click on points to get more information, take a snapshot of the current plot, etc.
```{r scatter-sub-dip_example, message=FALSE, eval=FALSE}
library(plotly)

scatter.plot <- ggplot(thesis.df,
                       aes(substrate_size_d50,
                           pct_diptera)) +
  geom_point(aes(color = lake)) +
  geom_smooth(method = "lm")

ggplotly(scatter.plot)
```



# Lesson 6: Child Documents

In general, I find that a single R Markdown file quickly becomes unwieldy. I recommend breaking the document up into multiple "child" documents and sourcing these child documents in a parent document. My child documents generally represent major subsections of the document. 

I prefer to store the parent R Markdown file in a folder labeled "markdown" (rproject/markdown) and the child R Markdown files in a sub-directory of my "markdown" folder called "sections" (rproject/markdown/sections). In the parent file, the child files are sourced within the code chunk header using `child = 'sections/example.Rmd'`. After sourcing all the child chunks, the parent file can be knit (compiled) like a normal R markdown document. The child documents cannot be run in the parent file.

![](img/rmarkdown/child_document.png)

## Extract and Run R-Code from R Markdown Files

The parent file is great for organizing sections of your document, but the child documents cannot be executed within R Studio like a normal code chunk. Without the ability to easily execute the R code within the child documents it can become very difficult to develop new child documents because new child documents often depend on upstream code execution. 

Imagine you have a parent document that sources child sections which import your data and clean your data. You now want to visualize your data; accordingly, you begin to develop a visualization child document, which depends on information from the upstream child sections. It would be inefficient and inappropriate to perform all the steps in the upstream child sections within the visualization section. Therefore, you need an effective way to execute the upstream child sections while you continue to develop the visualization section. The inefficient way of doing this is to open each child Rmd file in R Studio and execute them manually in the correct sequence. This becomes tedious after you have three or more documents (imagine doing this for 10+ child sections). The most efficient way that I have found to run upstream child sections is to extract the R-code chunks from each Rmd file, save them in a "raw_scripts" folder, and then source/execute the scripts within a regular R script file (.R).

###	R Code

In this section we establish the file path to the folder that contains all the child documents. The names of the child documents are extracted and stored as a vector. The `grepl()` function is used to retain only the Rmd files stored in the vector.

```{r, eval=FALSE}
sections.path <- file.path(rprojroot::find_root("r_in_practice.Rproj"),
                           "markdown",
                           "sections")
r.files.vec <- list.files(sections.path)
r.files.vec <- r.files.vec[grepl(".Rmd", r.files.vec)]
```

Next, a file path is specified for the R-scripts that will be extracted from the R Markdown documents; I place these files within a "raw_script/extracted" folder. The `map()` function from the purrr package is used to loop through each file in the vector (r.files.vec). Within the `map()` loop,  the `purl()` function from knitr is used to extract the R-code from the R Markdown documents and save the code to the specified folder.
```{r, eval=FALSE}
extracted.path <- file.path(rprojroot::find_root("r_in_practice.Rproj"),
                           "markdown",
                           "raw_scripts",
                           "extracted")

purrr::map(r.files.vec, function(file.i) {
  # print(file.i)
  file.name <- gsub(".Rmd", "", file.i)
  extracted.file <- paste0(file.name, ".R")
  knitr::purl(
    file.path(sections.path, file.i),
    file.path(extracted.path, extracted.file)
    )
})
```

Finally, create a vector of file names (`source.vec`) stored in the "raw_script/extracted" folder. You will want to type these out manually (do not use `list.files()` functions) because in this format you can easily comment out certain scripts and only run the scripts of interest. `map()` is then used to loop through each specified file in `source.vec`. Keep in mind that the order of the file names specified in `source.vec` will determine the order that these files are executed in the `map()` function; therefore, order the files in `source.vec` from furthest upstream to furthest downstream. Each iteration of the loop, executes (sources) the specified R-script. 
```{r, eval=FALSE}
source.vec <- c(
  "introduction.R",
  "quick_reference.R",
  "installation_updates.R",
  "r_project.R",
  "version_control.R"
)

purrr::map(source.vec, function(source.i) {
  source(file.path(extracted.path, source.i))
})
```

Once all the R-scripts extracted from the upstream child R Markdown files have been executed, you can begin or continue work on a new child R Markdown document. I keep all the above code in a single R-script and execute the entire script each time I use this file to make sure all of the files are up-to-date. 

## Your Turn

1. Create an R Markdown document for each of the sections, designated by Header level 1s, we have created thus far. 
    + save the documents within your project root (where your .Rproj file lives)
2. Copy the Header and the relevant content below the header. Paste the content into the appropriate R Markdown document.
3. Create a parent R Markdown document.
    + create a code chunk for each section.
    + add `child = 'insert-file-name-here.Rmd'` to the header of the appropriate code chunk
4. Knit the document


# Lesson 7: Parameterized Reports

Parameterized reports enable you to create a report template and generate reports for a subset of the data based on this template.

For example, imagine you are tasked with generating 100 one page fact sheets for lakes in your state. The fact sheets will include boilerplate language but for each lake's fact sheet you will need to update the name of the lake used through out the document, provide a list of metrics relevant to the lake (e.g., lake area, lat/longs, and max depth), and map of the lake. Think about how long it would take you to compile of the necessary components (e.g., lake metrics and lake maps), the amount of time it would take you to manually add these components to each fact sheet, and the struggles you would likely run into with formatting. Now imagine you complete all 100 fact sheets, hand the fact sheets to your boss, and they ask you to change the format of all the maps in the fact sheets. You would likely need to manually re-generate all of the maps and manually replace the maps in each document.

Here is a link to a great lecture on creating parameterized reports: https://www.coursera.org/lecture/reproducible-templates-analysis/adding-parameters-in-a-document-template-6fQwc

## params

To add a parameter or parameters to your document, add the `params:` argument below `output: html_document`. Below `params:` you can specify any parameter name you want to use and any default value you want to supply. In this example I will be using the `iris` data set, and therefore I specified that the name of my parameter would be "species" and the default value would be "setosa."

<center>
![](img/rmarkdown/param_yaml.png)
</center>

The specified parameter can be used throughout the document with the syntax `params$species`. `params$species` will act as a place holder throughout the document until the document is rendered and, in this case, the species is specified; this specified species will be used throughout the document where `params$species` was acting as a placeholder.

In the example below, I use inline code to insert the species name into the title of the document. Therefore, the title will automatically update during rendering depending on the specified parameter.


<center>
![](img/rmarkdown/param_yaml_dynamic_title.png)
</center>

The parameters can also be used to filter the original data frame to a subset of interest. For example, the iris data frame can be filtered to only include the specified species of interest using the code below.
```{r, eval=FALSE}
data(iris)

iris.sub <- iris[iris$Species %in% params$species, ]
```

The parameter can be referenced frequently to update the text in the document or to filter to the data of interest. In the image below, the iris data set will be filtered by the specified parameter to generate `iris.sub`. `iris.sub` will be used to calculate the mean value for each flower characteristic.

<center>
![](img/rmarkdown/param_iris-summary.png)
</center>

## Knitting

To the knit the document, click on the knit drop-down menu (the small triangle to the right of the Knit button) and select "Knit with Parameters..." A pop-up window will appear specifying the list of available parameters and their default values. These default values can be edited prior to clicking "knit" at the bottom right of the window.

<center>
![](img/rmarkdown/params_knit-with-parameters.png)
</center>

The document will then render.

<center>
![](img/rmarkdown/param_rendered-example.png){width=600px}
</center>

## rmarkdown::render()

The __rmarkdown__ function `render()` can also be used to compile the document. The `input` specifies the parameterized .Rmd file. The `params` argument species the parameter values to be used when rendering the document. Note that the value supplied to `params` must be wrapped by `list()`. 
```{r, eval=FALSE}
rmarkdown::render(input = "parameterized/param_template.Rmd",
                  params = list(species = "setosa"))
```

It would not be efficient to specify each parameter of interest one-by-one. Instead a loop can be written to iteratively generate parameterized documents. Below the function `lapply()` is used to create the loop. `unique(iris$Species)` supplies a vector of unique species names (i.e., "setosa", "versicolor", and "virginica") to generate parameterized reports. `species.i` is specified as a placeholder to represent each unique species in the iris data set; therefore `species.i` is used to specify what the species parameter should equal and it is used to generate a unique and easy to interpret file name `output_file = paste0(species.i, ".HTML")`.
```{r, eval=FALSE}
lapply(unique(iris$Species), function(species.i) {
  rmarkdown::render("parameterized/param_template.Rmd",
                    params = list(species = species.i),
                    output_file = paste0(species.i, ".HTML"))
})
```

## Your Turn

1. Create a new .Rmd file and copy/paste the content of the .Rmd file created in [Lesson 5: Code Chunks and Inline Code]
2. add `params:` and  specify lake as a parameter with Onondaga as the default (`lake: Onondaga`) to the YAML header
2. Use inline code to have the YAML title update to include the specified parameter (`params$lake`)
3. In your introductory paragraph, use inline code to specify that this document is specific to X Lake.
4. Filter `thesis.df` to only represent the specified lake parameter 
```{r filter-lake_example, eval=FALSE}
thesis.df <- thesis.df %>% 
  filter(lake %in% params$lake)
```
5. Update your conclusion section text to specify that the results are from X Lake and use inline code to specify:
    + the minimum relative abundance of Diptera taxa `min(thesis.df$pct_diptera)`
    + the maximum relative abundance of Diptera taxa `max(thesis.df$pct_diptera)`
    + the median richness value observed in the lake `median(thesis.df$richness)`
6. Render the document using the "Knit with Parameters..." button
   + Use the default parameter
   + Specify a different parameter (e.g., lake = Cazenovia)
7. __Bonus:__ Try to write a loop with `lapply()` and `render()` to automate the process to generate a report for each of the three lakes in the data set.
